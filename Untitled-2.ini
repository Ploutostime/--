# ...existing code...
v("OPENAI_API_BASE")  # 可选：例如 https://api.deepseek.com/
AI_MODEL = os.getenv("AI_Mimport os
import time
import logging
from typing import List, Dict, Optional

from openai import OpenAI
import pyttsx3

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# 配置：从环境变量读取，避免硬编码密钥
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
OPENAI_API_BASE = os.getenODEL", "deepseek-chat")  # 可选：可通过环境变量覆盖

if not OPENAI_API_KEY:
    logger.warning("未检测到 OPENAI_API_KEY 环境变量，调用 API 会失败。使用 setx 在 Windows 上设置。")

# 单例客户端和语音引擎
_CLIENT: Optional[OpenAI] = None
_TTS_ENGINE: Optional[pyttsx3.Engine] = None


def _init_client() -> OpenAI:
    global _CLIENT
    if _CLIENT is None:
        _CLIENT = OpenAI(api_key=OPENAI_API_KEY, base_url=OPENAI_API_BASE) if OPENAI_API_BASE else OpenAI(api_key=OPENAI_API_KEY)
    return _CLIENT


def _init_tts_engine() -> pyttsx3.Engine:
    global _TTS_ENGINE
    if _TTS_ENGINE is None:
        _TTS_ENGINE = pyttsx3.init()
        _TTS_ENGINE.setProperty("rate", 150)
        _TTS_ENGINE.setProperty("volume", 0.9)
        # 尝试选择中文语音（若存在）
        try:
            voices = _TTS_ENGINE.getProperty("voices")
            for v in voices:
                name = getattr(v, "name", "") or ""
                vid = getattr(v, "id", "") or ""
                if "chinese" in name.lower() or "zh" in vid.lower() or "zh" in name.lower():
                    _TTS_ENGINE.setProperty("voice", v.id)
                    break
        except Exception:
            logger.debug("获取语音列表失败，使用默认语音。")
    return _TTS_ENGINE


def 语音播报(文本: str, 阻塞: bool = True) -> None:
    """使用 pyttsx3 播报文本（复用引擎）"""
    try:
        引擎 = _init_tts_engine()
        引擎.say(文本)
        if 阻塞:
            引擎.runAndWait()
    except Exception as e:
        logger.error("语音播报失败: %s", e)


def 与AI对话(问题: str, 会话历史: Optional[List[Dict]] = None, 最大重试: int = 3) -> str:
    """
    向 AI 发送问题并返回回复。自动处理简单的重试与会话历史。
    会话历史格式：list of messages，形如 {"role": "user"|"assistant"|"system", "content": "..."}
    """
    client = _init_client()
    if not OPENAI_API_KEY:
        return "错误：未配置 OPENAI_API_KEY 环境变量。"

    messages = [{"role": "system", "content": "你是一个友好的助理，会用简洁中文回答用户的问题。"}]
    if 会话历史:
        messages.extend(会话历史)
    messages.append({"role": "user", "content": 问题})

    for attempt in range(1, 最大重试 + 1):
        try:
            resp = client.chat.completions.create(model=AI_MODEL, messages=messages)
            # 兼容返回格式
            回复内容 = ""
            if getattr(resp, "choices", None):
                回复内容 = resp.choices[0].message.content
            else:
                回复内容 = str(resp)

            logger.info("AI 回复: %s", 回复内容)
            # 异步或阻塞播报可由调用者决定，这里阻塞播报
            语音播报(回复内容, 阻塞=True)
            return 回复内容

        except Exception as e:
            logger.warning("与 AI 通信第 %d 次尝试失败: %s", attempt, e)
            if attempt < 最大重试:
                backoff = 2 ** (attempt - 1)
                time.sleep(backoff)
            else:
                错误信息 = f"发生错误: {e}"
                语音播报("抱歉，与 AI 通信时出现错误。", 阻塞=True)
                return 错误信息


if __name__ == "__main__":
    print("输入 '退出' 或 'exit' 结束会话。")
    history: List[Dict] = []
    while True:
        try:
            用户输入 = input("请输入您的问题: ").strip()
            if not 用户输入:
                continue
            if 用户输入.lower() in ("退出", "exit", "q", "quit"):
                print("已退出。")
                break
            回复 = 与AI对话(用户输入, 会话历史=history)
            # 将用户和助手消息加入历史，便于多轮对话
            history.append({"role": "user", "content": 用户输入})
            history.append({"role": "assistant", "content": 回复})
        except KeyboardInterrupt:
            print("\n已中断，退出。")
            break